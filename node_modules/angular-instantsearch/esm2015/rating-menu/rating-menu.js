import { Component, Input, Inject, forwardRef, Optional } from '@angular/core';
import { connectRatingMenu } from 'instantsearch.js/es/connectors';
import { TypedBaseWidget } from '../typed-base-widget';
import { NgAisInstantSearch } from '../instantsearch/instantsearch';
import { NgAisIndex } from '../index-widget/index-widget';
import { noop, parseNumberInput } from '../utils';
export class NgAisRatingMenu extends TypedBaseWidget {
    constructor(parentIndex, instantSearchInstance) {
        super('RatingMenu');
        this.parentIndex = parentIndex;
        this.instantSearchInstance = instantSearchInstance;
        // rendering options
        this.andUpLabel = '& Up';
        this.state = {
            createURL: () => '#',
            hasNoResults: false,
            items: [],
            refine: noop,
            canRefine: false,
            sendEvent: noop,
        };
    }
    get isHidden() {
        return this.state.items.length === 0 && this.autoHideContainer;
    }
    ngOnInit() {
        this.createWidget(connectRatingMenu, {
            attribute: this.attribute,
            max: parseNumberInput(this.max),
        }, {
            $$widgetType: 'ais.ratingMenu',
        });
        super.ngOnInit();
    }
    handleClick(event, value) {
        event.preventDefault();
        event.stopPropagation();
        this.state.refine(value);
    }
}
NgAisRatingMenu.decorators = [
    { type: Component, args: [{
                selector: 'ais-rating-menu',
                template: `
    <div
      [ngClass]="[
        cx(),
        state.items.length === 0 ? cx('', 'noRefinement') : ''
      ]"
      *ngIf="!isHidden"
    >
      <svg style="display:none;">
        <symbol
          id="ais-StarRating-starSymbol"
          viewBox="0 0 24 24"
        >
          <path d="M12 .288l2.833 8.718h9.167l-7.417 5.389 2.833 8.718-7.416-5.388-7.417 5.388 2.833-8.718-7.416-5.389h9.167z"/>
        </symbol>
        <symbol
          id="ais-StarRating-starEmptySymbol"
          viewBox="0 0 24 24"
        >
          <path d="M12 6.76l1.379 4.246h4.465l-3.612 2.625 1.379 4.246-3.611-2.625-3.612 2.625 1.379-4.246-3.612-2.625h4.465l1.38-4.246zm0-6.472l-2.833 8.718h-9.167l7.416 5.389-2.833 8.718 7.417-5.388 7.416 5.388-2.833-8.718 7.417-5.389h-9.167l-2.833-8.718z"/>
        </symbol>
      </svg>

      <ul [class]="cx('list')">
        <li
          *ngFor="let item of state.items"
          [class]="getItemClass(item)"
          (click)="handleClick($event, item.value)"
        >
          <a
            href="{{state.createURL(item.value)}}"
            [class]="cx('link')"
            (click)="handleClick($event, item.value)"
          >
            <svg
              width="24"
              height="24"
              *ngFor="let star of item.stars"
              [ngClass]="cx('starIcon') + ' ' + (star ? cx('starIcon', 'full') : cx('starIcon', 'empty'))"
              aria-hidden="true"
            >
              <use
                *ngIf="star"
                xlink:href="#ais-StarRating-starSymbol"
              >
              </use>

              <use
                *ngIf="!star"
                xlink:href="#ais-StarRating-starEmptySymbol"
              >
              </use>
            </svg>

            <span [class]="cx('label')" aria-hidden="true">{{andUpLabel}}</span>
            <span [class]="cx('count')">{{item.count}}</span>
          </a>
        </li>
      </ul>
    </div>
  `
            },] }
];
NgAisRatingMenu.ctorParameters = () => [
    { type: NgAisIndex, decorators: [{ type: Inject, args: [forwardRef(() => NgAisIndex),] }, { type: Optional }] },
    { type: NgAisInstantSearch, decorators: [{ type: Inject, args: [forwardRef(() => NgAisInstantSearch),] }] }
];
NgAisRatingMenu.propDecorators = {
    andUpLabel: [{ type: Input }],
    attribute: [{ type: Input }],
    max: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF0aW5nLW1lbnUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmF0aW5nLW1lbnUvcmF0aW5nLW1lbnUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFL0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBdUVsRCxNQUFNLE9BQU8sZUFBZ0IsU0FBUSxlQUdwQztJQXFCQyxZQUdTLFdBQXVCLEVBRXZCLHFCQUF5QztRQUVoRCxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFKYixnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUV2QiwwQkFBcUIsR0FBckIscUJBQXFCLENBQW9CO1FBekJsRCxvQkFBb0I7UUFDSixlQUFVLEdBQVcsTUFBTSxDQUFDO1FBTXJDLFVBQUssR0FBMEI7WUFDcEMsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUc7WUFDcEIsWUFBWSxFQUFFLEtBQUs7WUFDbkIsS0FBSyxFQUFFLEVBQUU7WUFDVCxNQUFNLEVBQUUsSUFBSTtZQUNaLFNBQVMsRUFBRSxLQUFLO1lBQ2hCLFNBQVMsRUFBRSxJQUFJO1NBQ2hCLENBQUM7SUFjRixDQUFDO0lBWkQsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztJQUNqRSxDQUFDO0lBWU0sUUFBUTtRQUNiLElBQUksQ0FBQyxZQUFZLENBQ2YsaUJBQWlCLEVBQ2pCO1lBQ0UsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3pCLEdBQUcsRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1NBQ2hDLEVBQ0Q7WUFDRSxZQUFZLEVBQUUsZ0JBQWdCO1NBQy9CLENBQ0YsQ0FBQztRQUNGLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRU0sV0FBVyxDQUFDLEtBQWlCLEVBQUUsS0FBYTtRQUNqRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdkIsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXhCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUM7OztZQXJIRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0RFQ7YUFDRjs7O1lBdkVRLFVBQVUsdUJBaUdkLE1BQU0sU0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQ25DLFFBQVE7WUFuR0osa0JBQWtCLHVCQXFHdEIsTUFBTSxTQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQzs7O3lCQXZCN0MsS0FBSzt3QkFHTCxLQUFLO2tCQUNMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBJbmplY3QsIGZvcndhcmRSZWYsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGNvbm5lY3RSYXRpbmdNZW51IH0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy9jb25uZWN0b3JzJztcbmltcG9ydCB7IFR5cGVkQmFzZVdpZGdldCB9IGZyb20gJy4uL3R5cGVkLWJhc2Utd2lkZ2V0JztcbmltcG9ydCB7IE5nQWlzSW5zdGFudFNlYXJjaCB9IGZyb20gJy4uL2luc3RhbnRzZWFyY2gvaW5zdGFudHNlYXJjaCc7XG5pbXBvcnQgeyBOZ0Fpc0luZGV4IH0gZnJvbSAnLi4vaW5kZXgtd2lkZ2V0L2luZGV4LXdpZGdldCc7XG5pbXBvcnQgeyBub29wLCBwYXJzZU51bWJlcklucHV0IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgUmF0aW5nTWVudUNvbm5lY3RvclBhcmFtcyxcbiAgUmF0aW5nTWVudVdpZGdldERlc2NyaXB0aW9uLFxuICBSYXRpbmdNZW51UmVuZGVyU3RhdGUsXG59IGZyb20gJ2luc3RhbnRzZWFyY2guanMvZXMvY29ubmVjdG9ycy9yYXRpbmctbWVudS9jb25uZWN0UmF0aW5nTWVudSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Fpcy1yYXRpbmctbWVudScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdlxuICAgICAgW25nQ2xhc3NdPVwiW1xuICAgICAgICBjeCgpLFxuICAgICAgICBzdGF0ZS5pdGVtcy5sZW5ndGggPT09IDAgPyBjeCgnJywgJ25vUmVmaW5lbWVudCcpIDogJydcbiAgICAgIF1cIlxuICAgICAgKm5nSWY9XCIhaXNIaWRkZW5cIlxuICAgID5cbiAgICAgIDxzdmcgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+XG4gICAgICAgIDxzeW1ib2xcbiAgICAgICAgICBpZD1cImFpcy1TdGFyUmF0aW5nLXN0YXJTeW1ib2xcIlxuICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgICA+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMiAuMjg4bDIuODMzIDguNzE4aDkuMTY3bC03LjQxNyA1LjM4OSAyLjgzMyA4LjcxOC03LjQxNi01LjM4OC03LjQxNyA1LjM4OCAyLjgzMy04LjcxOC03LjQxNi01LjM4OWg5LjE2N3pcIi8+XG4gICAgICAgIDwvc3ltYm9sPlxuICAgICAgICA8c3ltYm9sXG4gICAgICAgICAgaWQ9XCJhaXMtU3RhclJhdGluZy1zdGFyRW1wdHlTeW1ib2xcIlxuICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgICA+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMiA2Ljc2bDEuMzc5IDQuMjQ2aDQuNDY1bC0zLjYxMiAyLjYyNSAxLjM3OSA0LjI0Ni0zLjYxMS0yLjYyNS0zLjYxMiAyLjYyNSAxLjM3OS00LjI0Ni0zLjYxMi0yLjYyNWg0LjQ2NWwxLjM4LTQuMjQ2em0wLTYuNDcybC0yLjgzMyA4LjcxOGgtOS4xNjdsNy40MTYgNS4zODktMi44MzMgOC43MTggNy40MTctNS4zODggNy40MTYgNS4zODgtMi44MzMtOC43MTggNy40MTctNS4zODloLTkuMTY3bC0yLjgzMy04LjcxOHpcIi8+XG4gICAgICAgIDwvc3ltYm9sPlxuICAgICAgPC9zdmc+XG5cbiAgICAgIDx1bCBbY2xhc3NdPVwiY3goJ2xpc3QnKVwiPlxuICAgICAgICA8bGlcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzdGF0ZS5pdGVtc1wiXG4gICAgICAgICAgW2NsYXNzXT1cImdldEl0ZW1DbGFzcyhpdGVtKVwiXG4gICAgICAgICAgKGNsaWNrKT1cImhhbmRsZUNsaWNrKCRldmVudCwgaXRlbS52YWx1ZSlcIlxuICAgICAgICA+XG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGhyZWY9XCJ7e3N0YXRlLmNyZWF0ZVVSTChpdGVtLnZhbHVlKX19XCJcbiAgICAgICAgICAgIFtjbGFzc109XCJjeCgnbGluaycpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJoYW5kbGVDbGljaygkZXZlbnQsIGl0ZW0udmFsdWUpXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgIHdpZHRoPVwiMjRcIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIyNFwiXG4gICAgICAgICAgICAgICpuZ0Zvcj1cImxldCBzdGFyIG9mIGl0ZW0uc3RhcnNcIlxuICAgICAgICAgICAgICBbbmdDbGFzc109XCJjeCgnc3Rhckljb24nKSArICcgJyArIChzdGFyID8gY3goJ3N0YXJJY29uJywgJ2Z1bGwnKSA6IGN4KCdzdGFySWNvbicsICdlbXB0eScpKVwiXG4gICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDx1c2VcbiAgICAgICAgICAgICAgICAqbmdJZj1cInN0YXJcIlxuICAgICAgICAgICAgICAgIHhsaW5rOmhyZWY9XCIjYWlzLVN0YXJSYXRpbmctc3RhclN5bWJvbFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPC91c2U+XG5cbiAgICAgICAgICAgICAgPHVzZVxuICAgICAgICAgICAgICAgICpuZ0lmPVwiIXN0YXJcIlxuICAgICAgICAgICAgICAgIHhsaW5rOmhyZWY9XCIjYWlzLVN0YXJSYXRpbmctc3RhckVtcHR5U3ltYm9sXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8L3VzZT5cbiAgICAgICAgICAgIDwvc3ZnPlxuXG4gICAgICAgICAgICA8c3BhbiBbY2xhc3NdPVwiY3goJ2xhYmVsJylcIiBhcmlhLWhpZGRlbj1cInRydWVcIj57e2FuZFVwTGFiZWx9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIFtjbGFzc109XCJjeCgnY291bnQnKVwiPnt7aXRlbS5jb3VudH19PC9zcGFuPlxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cbiAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIE5nQWlzUmF0aW5nTWVudSBleHRlbmRzIFR5cGVkQmFzZVdpZGdldDxcbiAgUmF0aW5nTWVudVdpZGdldERlc2NyaXB0aW9uLFxuICBSYXRpbmdNZW51Q29ubmVjdG9yUGFyYW1zXG4+IHtcbiAgLy8gcmVuZGVyaW5nIG9wdGlvbnNcbiAgQElucHV0KCkgcHVibGljIGFuZFVwTGFiZWw6IHN0cmluZyA9ICcmIFVwJztcblxuICAvLyBpbnN0YW5jZSBvcHRpb25zXG4gIEBJbnB1dCgpIHB1YmxpYyBhdHRyaWJ1dGU6IHN0cmluZztcbiAgQElucHV0KCkgcHVibGljIG1heD86IG51bWJlcjtcblxuICBwdWJsaWMgc3RhdGU6IFJhdGluZ01lbnVSZW5kZXJTdGF0ZSA9IHtcbiAgICBjcmVhdGVVUkw6ICgpID0+ICcjJyxcbiAgICBoYXNOb1Jlc3VsdHM6IGZhbHNlLFxuICAgIGl0ZW1zOiBbXSxcbiAgICByZWZpbmU6IG5vb3AsXG4gICAgY2FuUmVmaW5lOiBmYWxzZSxcbiAgICBzZW5kRXZlbnQ6IG5vb3AsXG4gIH07XG5cbiAgZ2V0IGlzSGlkZGVuKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLml0ZW1zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmF1dG9IaWRlQ29udGFpbmVyO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE5nQWlzSW5kZXgpKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHVibGljIHBhcmVudEluZGV4OiBOZ0Fpc0luZGV4LFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ0Fpc0luc3RhbnRTZWFyY2gpKVxuICAgIHB1YmxpYyBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IE5nQWlzSW5zdGFudFNlYXJjaFxuICApIHtcbiAgICBzdXBlcignUmF0aW5nTWVudScpO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIHRoaXMuY3JlYXRlV2lkZ2V0KFxuICAgICAgY29ubmVjdFJhdGluZ01lbnUsXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZTogdGhpcy5hdHRyaWJ1dGUsXG4gICAgICAgIG1heDogcGFyc2VOdW1iZXJJbnB1dCh0aGlzLm1heCksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAkJHdpZGdldFR5cGU6ICdhaXMucmF0aW5nTWVudScsXG4gICAgICB9XG4gICAgKTtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG5cbiAgcHVibGljIGhhbmRsZUNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50LCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuc3RhdGUucmVmaW5lKHZhbHVlKTtcbiAgfVxufVxuIl19