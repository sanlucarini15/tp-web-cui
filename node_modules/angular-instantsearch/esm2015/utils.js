export function bem(widgetName) {
    const cx = function (element, subElement) {
        let cssClass = `ais-${widgetName}`;
        if (element) {
            cssClass += `-${element}`;
        }
        if (subElement) {
            cssClass += `--${subElement}`;
        }
        return cssClass;
    };
    return cx;
}
export function parseNumberInput(input) {
    return typeof input === 'string' ? parseInt(input, 10) : input;
}
export function noop(...args) { }
export function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}
// See https://github.com/algolia/instantsearch.js/blob/9296022fecadfbf82f15e837c215a1356eac4bc5/src/lib/utils/range.ts
export function range({ start = 0, end, step = 1, }) {
    // We can't divide by 0 so we re-assign the step to 1 if it happens.
    const limitStep = step === 0 ? 1 : step;
    // In some cases the array to create has a decimal length.
    // We therefore need to round the value.
    // Example:
    //   { start: 1, end: 5000, step: 500 }
    //   => Array length = (5000 - 1) / 500 = 9.998
    const arrayLength = Math.round((end - start) / limitStep);
    return [...Array(arrayLength)].map((_, current) => start + current * limitStep);
}
// See https://github.com/algolia/react-instantsearch/blob/86dfe8674d566124af55a8f044051d0062786c1a/packages/react-instantsearch-core/src/core/utils.ts#L138-L142
export function getPropertyByPath(object, path) {
    return path
        .replace(/\[(\d+)]/g, '.$1')
        .split('.')
        .reduce((current, key) => (current ? current[key] : undefined), object);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxVQUFVLEdBQUcsQ0FBQyxVQUFrQjtJQUNwQyxNQUFNLEVBQUUsR0FBRyxVQUFTLE9BQWdCLEVBQUUsVUFBbUI7UUFDdkQsSUFBSSxRQUFRLEdBQUcsT0FBTyxVQUFVLEVBQUUsQ0FBQztRQUNuQyxJQUFJLE9BQU8sRUFBRTtZQUNYLFFBQVEsSUFBSSxJQUFJLE9BQU8sRUFBRSxDQUFDO1NBQzNCO1FBQ0QsSUFBSSxVQUFVLEVBQUU7WUFDZCxRQUFRLElBQUksS0FBSyxVQUFVLEVBQUUsQ0FBQztTQUMvQjtRQUNELE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUMsQ0FBQztJQUNGLE9BQU8sRUFBRSxDQUFDO0FBQ1osQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxLQUF1QjtJQUN0RCxPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ2pFLENBQUM7QUFFRCxNQUFNLFVBQVUsSUFBSSxDQUFDLEdBQUcsSUFBVyxJQUFTLENBQUM7QUFFN0MsTUFBTSxVQUFVLFVBQVUsQ0FBQyxDQUFDO0lBQzFCLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hELENBQUM7QUFFRCx1SEFBdUg7QUFDdkgsTUFBTSxVQUFVLEtBQUssQ0FBQyxFQUNwQixLQUFLLEdBQUcsQ0FBQyxFQUNULEdBQUcsRUFDSCxJQUFJLEdBQUcsQ0FBQyxHQUtUO0lBQ0Msb0VBQW9FO0lBQ3BFLE1BQU0sU0FBUyxHQUFHLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBRXhDLDBEQUEwRDtJQUMxRCx3Q0FBd0M7SUFDeEMsV0FBVztJQUNYLHVDQUF1QztJQUN2QywrQ0FBK0M7SUFDL0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztJQUUxRCxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQ2hDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUMsS0FBSyxHQUFHLE9BQU8sR0FBRyxTQUFTLENBQzVDLENBQUM7QUFDSixDQUFDO0FBRUQsaUtBQWlLO0FBQ2pLLE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxNQUFjLEVBQUUsSUFBWTtJQUM1RCxPQUFPLElBQUk7U0FDUixPQUFPLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQztTQUMzQixLQUFLLENBQUMsR0FBRyxDQUFDO1NBQ1YsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDNUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBiZW0od2lkZ2V0TmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IGN4ID0gZnVuY3Rpb24oZWxlbWVudD86IHN0cmluZywgc3ViRWxlbWVudD86IHN0cmluZykge1xuICAgIGxldCBjc3NDbGFzcyA9IGBhaXMtJHt3aWRnZXROYW1lfWA7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNzc0NsYXNzICs9IGAtJHtlbGVtZW50fWA7XG4gICAgfVxuICAgIGlmIChzdWJFbGVtZW50KSB7XG4gICAgICBjc3NDbGFzcyArPSBgLS0ke3N1YkVsZW1lbnR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNzc0NsYXNzO1xuICB9O1xuICByZXR1cm4gY3g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU51bWJlcklucHV0KGlucHV0PzogbnVtYmVyIHwgc3RyaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQoaW5wdXQsIDEwKSA6IGlucHV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCguLi5hcmdzOiBhbnlbXSk6IHZvaWQge31cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9pbnN0YW50c2VhcmNoLmpzL2Jsb2IvOTI5NjAyMmZlY2FkZmJmODJmMTVlODM3YzIxNWExMzU2ZWFjNGJjNS9zcmMvbGliL3V0aWxzL3JhbmdlLnRzXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uoe1xuICBzdGFydCA9IDAsXG4gIGVuZCxcbiAgc3RlcCA9IDEsXG59OiB7XG4gIHN0YXJ0PzogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgc3RlcD86IG51bWJlcjtcbn0pOiBudW1iZXJbXSB7XG4gIC8vIFdlIGNhbid0IGRpdmlkZSBieSAwIHNvIHdlIHJlLWFzc2lnbiB0aGUgc3RlcCB0byAxIGlmIGl0IGhhcHBlbnMuXG4gIGNvbnN0IGxpbWl0U3RlcCA9IHN0ZXAgPT09IDAgPyAxIDogc3RlcDtcblxuICAvLyBJbiBzb21lIGNhc2VzIHRoZSBhcnJheSB0byBjcmVhdGUgaGFzIGEgZGVjaW1hbCBsZW5ndGguXG4gIC8vIFdlIHRoZXJlZm9yZSBuZWVkIHRvIHJvdW5kIHRoZSB2YWx1ZS5cbiAgLy8gRXhhbXBsZTpcbiAgLy8gICB7IHN0YXJ0OiAxLCBlbmQ6IDUwMDAsIHN0ZXA6IDUwMCB9XG4gIC8vICAgPT4gQXJyYXkgbGVuZ3RoID0gKDUwMDAgLSAxKSAvIDUwMCA9IDkuOTk4XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gTWF0aC5yb3VuZCgoZW5kIC0gc3RhcnQpIC8gbGltaXRTdGVwKTtcblxuICByZXR1cm4gWy4uLkFycmF5KGFycmF5TGVuZ3RoKV0ubWFwKFxuICAgIChfLCBjdXJyZW50KSA9PiBzdGFydCArIGN1cnJlbnQgKiBsaW1pdFN0ZXBcbiAgKTtcbn1cblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL3JlYWN0LWluc3RhbnRzZWFyY2gvYmxvYi84NmRmZTg2NzRkNTY2MTI0YWY1NWE4ZjA0NDA1MWQwMDYyNzg2YzFhL3BhY2thZ2VzL3JlYWN0LWluc3RhbnRzZWFyY2gtY29yZS9zcmMvY29yZS91dGlscy50cyNMMTM4LUwxNDJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wZXJ0eUJ5UGF0aChvYmplY3Q6IG9iamVjdCwgcGF0aDogc3RyaW5nKTogYW55IHtcbiAgcmV0dXJuIHBhdGhcbiAgICAucmVwbGFjZSgvXFxbKFxcZCspXS9nLCAnLiQxJylcbiAgICAuc3BsaXQoJy4nKVxuICAgIC5yZWR1Y2UoKGN1cnJlbnQsIGtleSkgPT4gKGN1cnJlbnQgPyBjdXJyZW50W2tleV0gOiB1bmRlZmluZWQpLCBvYmplY3QpO1xufVxuIl19