import { Component, ContentChild, TemplateRef, Inject, forwardRef, Input, Optional, } from '@angular/core';
import { connectQueryRules } from 'instantsearch.js/es/connectors';
import { TypedBaseWidget } from '../typed-base-widget';
import { NgAisInstantSearch } from '../instantsearch/instantsearch';
import { NgAisIndex } from '../index-widget/index-widget';
export class NgAisQueryRuleCustomData extends TypedBaseWidget {
    constructor(parentIndex, instantSearchInstance) {
        super('QueryRuleCustomData');
        this.parentIndex = parentIndex;
        this.instantSearchInstance = instantSearchInstance;
        this.state = {
            items: [],
        };
    }
    get templateContext() {
        return {
            items: this.state.items,
        };
    }
    ngOnInit() {
        this.createWidget(connectQueryRules, {
            transformItems: this.transformItems,
        }, {
            $$widgetType: 'ais.queryRuleCustomData',
        });
        super.ngOnInit();
    }
}
NgAisQueryRuleCustomData.decorators = [
    { type: Component, args: [{
                selector: 'ais-query-rule-custom-data',
                template: `
    <div [class]='cx()'>
      <ng-container *ngTemplateOutlet='template; context: templateContext'>
      </ng-container>

      <div *ngIf='!template'>
        <div *ngFor='let item of state.items'>
          <pre>{{ item | json }}</pre>
        </div>
      </div>
    </div>
  `
            },] }
];
NgAisQueryRuleCustomData.ctorParameters = () => [
    { type: NgAisIndex, decorators: [{ type: Inject, args: [forwardRef(() => NgAisIndex),] }, { type: Optional }] },
    { type: NgAisInstantSearch, decorators: [{ type: Inject, args: [forwardRef(() => NgAisInstantSearch),] }] }
];
NgAisQueryRuleCustomData.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef, { static: false },] }],
    transformItems: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVlcnktcnVsZS1jdXN0b20tZGF0YS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9xdWVyeS1ydWxlLWN1c3RvbS1kYXRhL3F1ZXJ5LXJ1bGUtY3VzdG9tLWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixVQUFVLEVBQ1YsS0FBSyxFQUNMLFFBQVEsR0FDVCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQU9uRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDcEUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBaUIxRCxNQUFNLE9BQU8sd0JBQXlCLFNBQVEsZUFHN0M7SUFnQkMsWUFHUyxXQUF1QixFQUV2QixxQkFBeUM7UUFFaEQsS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFKdEIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFFdkIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFvQjtRQWYzQyxVQUFLLEdBQTBCO1lBQ3BDLEtBQUssRUFBRSxFQUFFO1NBQ1YsQ0FBQztJQWdCRixDQUFDO0lBZEQsSUFBSSxlQUFlO1FBQ2pCLE9BQU87WUFDTCxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLO1NBQ3hCLENBQUM7SUFDSixDQUFDO0lBWU0sUUFBUTtRQUNiLElBQUksQ0FBQyxZQUFZLENBQ2YsaUJBQWlCLEVBQ2pCO1lBQ0UsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjO1NBQ3BDLEVBQ0Q7WUFDRSxZQUFZLEVBQUUseUJBQXlCO1NBQ3hDLENBQ0YsQ0FBQztRQUVGLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDOzs7WUF4REYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSw0QkFBNEI7Z0JBQ3RDLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7R0FXVDthQUNGOzs7WUFoQlEsVUFBVSx1QkFxQ2QsTUFBTSxTQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FDbkMsUUFBUTtZQXZDSixrQkFBa0IsdUJBeUN0QixNQUFNLFNBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDOzs7dUJBbkI3QyxZQUFZLFNBQUMsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTs2QkFHM0MsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBUZW1wbGF0ZVJlZixcbiAgSW5qZWN0LFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCxcbiAgT3B0aW9uYWwsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBjb25uZWN0UXVlcnlSdWxlcyB9IGZyb20gJ2luc3RhbnRzZWFyY2guanMvZXMvY29ubmVjdG9ycyc7XG5pbXBvcnQge1xuICBRdWVyeVJ1bGVzQ29ubmVjdG9yUGFyYW1zLFxuICBRdWVyeVJ1bGVzV2lkZ2V0RGVzY3JpcHRpb24sXG4gIFF1ZXJ5UnVsZXNSZW5kZXJTdGF0ZSxcbn0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy9jb25uZWN0b3JzL3F1ZXJ5LXJ1bGVzL2Nvbm5lY3RRdWVyeVJ1bGVzJztcblxuaW1wb3J0IHsgVHlwZWRCYXNlV2lkZ2V0IH0gZnJvbSAnLi4vdHlwZWQtYmFzZS13aWRnZXQnO1xuaW1wb3J0IHsgTmdBaXNJbnN0YW50U2VhcmNoIH0gZnJvbSAnLi4vaW5zdGFudHNlYXJjaC9pbnN0YW50c2VhcmNoJztcbmltcG9ydCB7IE5nQWlzSW5kZXggfSBmcm9tICcuLi9pbmRleC13aWRnZXQvaW5kZXgtd2lkZ2V0JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWlzLXF1ZXJ5LXJ1bGUtY3VzdG9tLWRhdGEnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgW2NsYXNzXT0nY3goKSc+XG4gICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PSd0ZW1wbGF0ZTsgY29udGV4dDogdGVtcGxhdGVDb250ZXh0Jz5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICA8ZGl2ICpuZ0lmPSchdGVtcGxhdGUnPlxuICAgICAgICA8ZGl2ICpuZ0Zvcj0nbGV0IGl0ZW0gb2Ygc3RhdGUuaXRlbXMnPlxuICAgICAgICAgIDxwcmU+e3sgaXRlbSB8IGpzb24gfX08L3ByZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgTmdBaXNRdWVyeVJ1bGVDdXN0b21EYXRhIGV4dGVuZHMgVHlwZWRCYXNlV2lkZ2V0PFxuICBRdWVyeVJ1bGVzV2lkZ2V0RGVzY3JpcHRpb24sXG4gIFF1ZXJ5UnVsZXNDb25uZWN0b3JQYXJhbXNcbj4ge1xuICBAQ29udGVudENoaWxkKFRlbXBsYXRlUmVmLCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgcHVibGljIHRlbXBsYXRlOiBhbnk7XG5cbiAgQElucHV0KCkgcHVibGljIHRyYW5zZm9ybUl0ZW1zPzogUXVlcnlSdWxlc0Nvbm5lY3RvclBhcmFtc1sndHJhbnNmb3JtSXRlbXMnXTtcblxuICBwdWJsaWMgc3RhdGU6IFF1ZXJ5UnVsZXNSZW5kZXJTdGF0ZSA9IHtcbiAgICBpdGVtczogW10sXG4gIH07XG5cbiAgZ2V0IHRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXM6IHRoaXMuc3RhdGUuaXRlbXMsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ0Fpc0luZGV4KSlcbiAgICBAT3B0aW9uYWwoKVxuICAgIHB1YmxpYyBwYXJlbnRJbmRleDogTmdBaXNJbmRleCxcbiAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gTmdBaXNJbnN0YW50U2VhcmNoKSlcbiAgICBwdWJsaWMgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBOZ0Fpc0luc3RhbnRTZWFyY2hcbiAgKSB7XG4gICAgc3VwZXIoJ1F1ZXJ5UnVsZUN1c3RvbURhdGEnKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmNyZWF0ZVdpZGdldChcbiAgICAgIGNvbm5lY3RRdWVyeVJ1bGVzLFxuICAgICAge1xuICAgICAgICB0cmFuc2Zvcm1JdGVtczogdGhpcy50cmFuc2Zvcm1JdGVtcyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICQkd2lkZ2V0VHlwZTogJ2Fpcy5xdWVyeVJ1bGVDdXN0b21EYXRhJyxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgfVxufVxuIl19