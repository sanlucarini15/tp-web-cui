/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Inject, forwardRef } from '@angular/core';
import { connectToggleRefinement } from 'instantsearch.js/es/connectors';
import { BaseWidget } from '../base-widget';
import { NgAisInstantSearch } from '../instantsearch/instantsearch';
import { noop } from '../utils';
export class NgAisToggle extends BaseWidget {
    /**
     * @param {?} instantSearchParent
     */
    constructor(instantSearchParent) {
        super('ToggleRefinement');
        this.instantSearchParent = instantSearchParent;
        this.state = {
            createURL: noop,
            refine: noop,
            value: {},
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.createWidget(connectToggleRefinement, {
            attribute: this.attribute,
            on: this.on,
            off: this.off,
        });
        super.ngOnInit();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this.state.refine(this.state.value);
    }
}
NgAisToggle.decorators = [
    { type: Component, args: [{
                selector: 'ais-toggle',
                template: `
    <div [class]="cx()">
      <label [class]="cx('label')">
        <input
          [class]="cx('checkbox')"
          type="checkbox"
          value="{{state.value.name}}"
          [checked]="state.value.isRefined"
          (change)="handleChange($event)"
        />

        <span [class]="cx('labelText')">
          {{label || state.value.name}}
        </span>

        <span [class]="cx('count')">{{state.value.count}}</span>
      </label>
    </div>
  `
            }] }
];
/** @nocollapse */
NgAisToggle.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgAisInstantSearch)),] }] }
];
NgAisToggle.propDecorators = {
    label: [{ type: Input }],
    attribute: [{ type: Input }],
    on: [{ type: Input }],
    off: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NgAisToggle.prototype.label;
    /** @type {?} */
    NgAisToggle.prototype.attribute;
    /** @type {?} */
    NgAisToggle.prototype.on;
    /** @type {?} */
    NgAisToggle.prototype.off;
    /** @type {?} */
    NgAisToggle.prototype.state;
    /** @type {?} */
    NgAisToggle.prototype.instantSearchParent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1pbnN0YW50c2VhcmNoLyIsInNvdXJjZXMiOlsidG9nZ2xlL3RvZ2dsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVyRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN6RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDcEUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFVBQVUsQ0FBQztBQTBDaEMsTUFBTSxPQUFPLFdBQVksU0FBUSxVQUFVOzs7O0lBZXpDLFlBRVMsbUJBQXdCO1FBRS9CLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBRm5CLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBSztRQVIxQixVQUFLLEdBQWdCO1lBQzFCLFNBQVMsRUFBRSxJQUFJO1lBQ2YsTUFBTSxFQUFFLElBQUk7WUFDWixLQUFLLEVBQUUsRUFBRTtTQUNWLENBQUM7SUFPRixDQUFDOzs7O0lBRU0sUUFBUTtRQUNiLElBQUksQ0FBQyxZQUFZLENBQUMsdUJBQXVCLEVBQUU7WUFDekMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3pCLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRTtZQUNYLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztTQUNkLENBQUMsQ0FBQztRQUNILEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDOzs7OztJQUVNLFlBQVksQ0FBQyxLQUFpQjtRQUNuQyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdkIsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEMsQ0FBQzs7O1lBekRGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsWUFBWTtnQkFDdEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQlQ7YUFDRjs7Ozs0Q0FpQkksTUFBTSxTQUFDLFVBQVU7OztvQkFBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsRUFBQzs7O29CQWQ3QyxLQUFLO3dCQUdMLEtBQUs7aUJBQ0wsS0FBSztrQkFDTCxLQUFLOzs7O0lBTE4sNEJBQThCOztJQUc5QixnQ0FBa0M7O0lBQ2xDLHlCQUErQzs7SUFDL0MsMEJBQWdEOztJQUVoRCw0QkFJRTs7SUFHQSwwQ0FDK0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBJbmplY3QsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgY29ubmVjdFRvZ2dsZVJlZmluZW1lbnQgfSBmcm9tICdpbnN0YW50c2VhcmNoLmpzL2VzL2Nvbm5lY3RvcnMnO1xuaW1wb3J0IHsgQmFzZVdpZGdldCB9IGZyb20gJy4uL2Jhc2Utd2lkZ2V0JztcbmltcG9ydCB7IE5nQWlzSW5zdGFudFNlYXJjaCB9IGZyb20gJy4uL2luc3RhbnRzZWFyY2gvaW5zdGFudHNlYXJjaCc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBUb2dnbGVTdGF0ZSA9IHtcbiAgY3JlYXRlVVJMOiBGdW5jdGlvbjtcbiAgcmVmaW5lOiBGdW5jdGlvbjtcbiAgdmFsdWU6IHtcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIGNvdW50PzogbnVtYmVyO1xuICAgIGlzUmVmaW5lZD86IGJvb2xlYW47XG4gICAgb25GYWNldFZhbHVlPzoge1xuICAgICAgaXNSZWZpbmVkOiBib29sZWFuO1xuICAgICAgY291bnQ6IG51bWJlcjtcbiAgICB9O1xuICAgIG9mZkZhY2V0VmFsdWU/OiB7XG4gICAgICBpc1JlZmluZWQ6IGJvb2xlYW47XG4gICAgICBjb3VudDogbnVtYmVyO1xuICAgIH07XG4gIH07XG59O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdhaXMtdG9nZ2xlJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IFtjbGFzc109XCJjeCgpXCI+XG4gICAgICA8bGFiZWwgW2NsYXNzXT1cImN4KCdsYWJlbCcpXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIFtjbGFzc109XCJjeCgnY2hlY2tib3gnKVwiXG4gICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICB2YWx1ZT1cInt7c3RhdGUudmFsdWUubmFtZX19XCJcbiAgICAgICAgICBbY2hlY2tlZF09XCJzdGF0ZS52YWx1ZS5pc1JlZmluZWRcIlxuICAgICAgICAgIChjaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAvPlxuXG4gICAgICAgIDxzcGFuIFtjbGFzc109XCJjeCgnbGFiZWxUZXh0JylcIj5cbiAgICAgICAgICB7e2xhYmVsIHx8IHN0YXRlLnZhbHVlLm5hbWV9fVxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgPHNwYW4gW2NsYXNzXT1cImN4KCdjb3VudCcpXCI+e3tzdGF0ZS52YWx1ZS5jb3VudH19PC9zcGFuPlxuICAgICAgPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgTmdBaXNUb2dnbGUgZXh0ZW5kcyBCYXNlV2lkZ2V0IHtcbiAgLy8gcmVuZGVyaW5nIG9wdGlvbnNcbiAgQElucHV0KCkgcHVibGljIGxhYmVsOiBzdHJpbmc7XG5cbiAgLy8gaW5zdGFuY2Ugb3B0aW9uc1xuICBASW5wdXQoKSBwdWJsaWMgYXR0cmlidXRlOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHB1YmxpYyBvbj86IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmc7XG4gIEBJbnB1dCgpIHB1YmxpYyBvZmY/OiBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nO1xuXG4gIHB1YmxpYyBzdGF0ZTogVG9nZ2xlU3RhdGUgPSB7XG4gICAgY3JlYXRlVVJMOiBub29wLFxuICAgIHJlZmluZTogbm9vcCxcbiAgICB2YWx1ZToge30sXG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE5nQWlzSW5zdGFudFNlYXJjaCkpXG4gICAgcHVibGljIGluc3RhbnRTZWFyY2hQYXJlbnQ6IGFueVxuICApIHtcbiAgICBzdXBlcignVG9nZ2xlUmVmaW5lbWVudCcpO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIHRoaXMuY3JlYXRlV2lkZ2V0KGNvbm5lY3RUb2dnbGVSZWZpbmVtZW50LCB7XG4gICAgICBhdHRyaWJ1dGU6IHRoaXMuYXR0cmlidXRlLFxuICAgICAgb246IHRoaXMub24sXG4gICAgICBvZmY6IHRoaXMub2ZmLFxuICAgIH0pO1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gIH1cblxuICBwdWJsaWMgaGFuZGxlQ2hhbmdlKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLnN0YXRlLnJlZmluZSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgfVxufVxuIl19